/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: record_metadata.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./google/protobuf/descriptor";
import * as dependency_2 from "./google/protobuf/any";
import * as pb_1 from "google-protobuf";
export namespace webaas.db.record {
    export class DataStoreInfo extends pb_1.Message {
        constructor(data?: any[] | {
            formatVersion?: number;
            metaDataversion?: number;
            userVersion?: number;
            record_count_key?: KeyExpression;
            lastUpdateTime?: number;
            omit_unsplit_record_suffix?: boolean;
            cacheable?: boolean;
            user_field?: DataStoreInfo.UserFieldEntry[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [8], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("formatVersion" in data && data.formatVersion != undefined) {
                    this.formatVersion = data.formatVersion;
                }
                if ("metaDataversion" in data && data.metaDataversion != undefined) {
                    this.metaDataversion = data.metaDataversion;
                }
                if ("userVersion" in data && data.userVersion != undefined) {
                    this.userVersion = data.userVersion;
                }
                if ("record_count_key" in data && data.record_count_key != undefined) {
                    this.record_count_key = data.record_count_key;
                }
                if ("lastUpdateTime" in data && data.lastUpdateTime != undefined) {
                    this.lastUpdateTime = data.lastUpdateTime;
                }
                if ("omit_unsplit_record_suffix" in data && data.omit_unsplit_record_suffix != undefined) {
                    this.omit_unsplit_record_suffix = data.omit_unsplit_record_suffix;
                }
                if ("cacheable" in data && data.cacheable != undefined) {
                    this.cacheable = data.cacheable;
                }
                if ("user_field" in data && data.user_field != undefined) {
                    this.user_field = data.user_field;
                }
            }
        }
        get formatVersion() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set formatVersion(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get metaDataversion() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set metaDataversion(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get userVersion() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set userVersion(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get record_count_key() {
            return pb_1.Message.getWrapperField(this, KeyExpression, 4) as KeyExpression;
        }
        set record_count_key(value: KeyExpression) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get lastUpdateTime() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set lastUpdateTime(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get omit_unsplit_record_suffix() {
            return pb_1.Message.getField(this, 6) as boolean;
        }
        set omit_unsplit_record_suffix(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        get cacheable() {
            return pb_1.Message.getField(this, 7) as boolean;
        }
        set cacheable(value: boolean) {
            pb_1.Message.setField(this, 7, value);
        }
        get user_field() {
            return pb_1.Message.getRepeatedWrapperField(this, DataStoreInfo.UserFieldEntry, 8) as DataStoreInfo.UserFieldEntry[];
        }
        set user_field(value: DataStoreInfo.UserFieldEntry[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        static fromObject(data: {
            formatVersion?: number;
            metaDataversion?: number;
            userVersion?: number;
            record_count_key?: ReturnType<typeof KeyExpression.prototype.toObject>;
            lastUpdateTime?: number;
            omit_unsplit_record_suffix?: boolean;
            cacheable?: boolean;
            user_field?: ReturnType<typeof DataStoreInfo.UserFieldEntry.prototype.toObject>[];
        }) {
            const message = new DataStoreInfo({});
            if (data.formatVersion != null) {
                message.formatVersion = data.formatVersion;
            }
            if (data.metaDataversion != null) {
                message.metaDataversion = data.metaDataversion;
            }
            if (data.userVersion != null) {
                message.userVersion = data.userVersion;
            }
            if (data.record_count_key != null) {
                message.record_count_key = KeyExpression.fromObject(data.record_count_key);
            }
            if (data.lastUpdateTime != null) {
                message.lastUpdateTime = data.lastUpdateTime;
            }
            if (data.omit_unsplit_record_suffix != null) {
                message.omit_unsplit_record_suffix = data.omit_unsplit_record_suffix;
            }
            if (data.cacheable != null) {
                message.cacheable = data.cacheable;
            }
            if (data.user_field != null) {
                message.user_field = data.user_field.map(item => DataStoreInfo.UserFieldEntry.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                formatVersion?: number;
                metaDataversion?: number;
                userVersion?: number;
                record_count_key?: ReturnType<typeof KeyExpression.prototype.toObject>;
                lastUpdateTime?: number;
                omit_unsplit_record_suffix?: boolean;
                cacheable?: boolean;
                user_field?: ReturnType<typeof DataStoreInfo.UserFieldEntry.prototype.toObject>[];
            } = {};
            if (this.formatVersion != null) {
                data.formatVersion = this.formatVersion;
            }
            if (this.metaDataversion != null) {
                data.metaDataversion = this.metaDataversion;
            }
            if (this.userVersion != null) {
                data.userVersion = this.userVersion;
            }
            if (this.record_count_key != null) {
                data.record_count_key = this.record_count_key.toObject();
            }
            if (this.lastUpdateTime != null) {
                data.lastUpdateTime = this.lastUpdateTime;
            }
            if (this.omit_unsplit_record_suffix != null) {
                data.omit_unsplit_record_suffix = this.omit_unsplit_record_suffix;
            }
            if (this.cacheable != null) {
                data.cacheable = this.cacheable;
            }
            if (this.user_field != null) {
                data.user_field = this.user_field.map((item: DataStoreInfo.UserFieldEntry) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.formatVersion !== undefined)
                writer.writeInt32(1, this.formatVersion);
            if (this.metaDataversion !== undefined)
                writer.writeInt32(2, this.metaDataversion);
            if (this.userVersion !== undefined)
                writer.writeInt32(3, this.userVersion);
            if (this.record_count_key !== undefined)
                writer.writeMessage(4, this.record_count_key, () => this.record_count_key.serialize(writer));
            if (this.lastUpdateTime !== undefined)
                writer.writeUint64(5, this.lastUpdateTime);
            if (this.omit_unsplit_record_suffix !== undefined)
                writer.writeBool(6, this.omit_unsplit_record_suffix);
            if (this.cacheable !== undefined)
                writer.writeBool(7, this.cacheable);
            if (this.user_field !== undefined)
                writer.writeRepeatedMessage(8, this.user_field, (item: DataStoreInfo.UserFieldEntry) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DataStoreInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DataStoreInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.formatVersion = reader.readInt32();
                        break;
                    case 2:
                        message.metaDataversion = reader.readInt32();
                        break;
                    case 3:
                        message.userVersion = reader.readInt32();
                        break;
                    case 4:
                        reader.readMessage(message.record_count_key, () => message.record_count_key = KeyExpression.deserialize(reader));
                        break;
                    case 5:
                        message.lastUpdateTime = reader.readUint64();
                        break;
                    case 6:
                        message.omit_unsplit_record_suffix = reader.readBool();
                        break;
                    case 7:
                        message.cacheable = reader.readBool();
                        break;
                    case 8:
                        reader.readMessage(message.user_field, () => pb_1.Message.addToRepeatedWrapperField(message, 8, DataStoreInfo.UserFieldEntry.deserialize(reader), DataStoreInfo.UserFieldEntry));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DataStoreInfo {
            return DataStoreInfo.deserialize(bytes);
        }
    }
    export namespace DataStoreInfo {
        export class UserFieldEntry extends pb_1.Message {
            constructor(data?: any[] | {
                key?: string;
                value?: Uint8Array;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("key" in data && data.key != undefined) {
                        this.key = data.key;
                    }
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get key() {
                return pb_1.Message.getField(this, 1) as string;
            }
            set key(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get value() {
                return pb_1.Message.getField(this, 2) as Uint8Array;
            }
            set value(value: Uint8Array) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                key?: string;
                value?: Uint8Array;
            }) {
                const message = new UserFieldEntry({});
                if (data.key != null) {
                    message.key = data.key;
                }
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    key?: string;
                    value?: Uint8Array;
                } = {};
                if (this.key != null) {
                    data.key = this.key;
                }
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (typeof this.key === "string" && this.key.length)
                    writer.writeString(1, this.key);
                if (this.value !== undefined)
                    writer.writeBytes(2, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UserFieldEntry {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UserFieldEntry();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.key = reader.readString();
                            break;
                        case 2:
                            message.value = reader.readBytes();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): UserFieldEntry {
                return UserFieldEntry.deserialize(bytes);
            }
        }
    }
    export class Index extends pb_1.Message {
        constructor(data?: any[] | {
            record_type?: string[];
            name?: string;
            root_expression?: KeyExpression;
            subspace_key?: Uint8Array;
            last_modified_version?: number;
            type?: string;
            options?: Index.Option[];
            added_version?: number;
            unique?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 7], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("record_type" in data && data.record_type != undefined) {
                    this.record_type = data.record_type;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("root_expression" in data && data.root_expression != undefined) {
                    this.root_expression = data.root_expression;
                }
                if ("subspace_key" in data && data.subspace_key != undefined) {
                    this.subspace_key = data.subspace_key;
                }
                if ("last_modified_version" in data && data.last_modified_version != undefined) {
                    this.last_modified_version = data.last_modified_version;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("options" in data && data.options != undefined) {
                    this.options = data.options;
                }
                if ("added_version" in data && data.added_version != undefined) {
                    this.added_version = data.added_version;
                }
                if ("unique" in data && data.unique != undefined) {
                    this.unique = data.unique;
                }
            }
        }
        get record_type() {
            return pb_1.Message.getField(this, 1) as string[];
        }
        set record_type(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get name() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get root_expression() {
            return pb_1.Message.getWrapperField(this, KeyExpression, 3) as KeyExpression;
        }
        set root_expression(value: KeyExpression) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get subspace_key() {
            return pb_1.Message.getField(this, 4) as Uint8Array;
        }
        set subspace_key(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get last_modified_version() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set last_modified_version(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get type() {
            return pb_1.Message.getField(this, 6) as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get options() {
            return pb_1.Message.getRepeatedWrapperField(this, Index.Option, 7) as Index.Option[];
        }
        set options(value: Index.Option[]) {
            pb_1.Message.setRepeatedWrapperField(this, 7, value);
        }
        get added_version() {
            return pb_1.Message.getField(this, 8) as number;
        }
        set added_version(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get unique() {
            return pb_1.Message.getField(this, 9) as boolean;
        }
        set unique(value: boolean) {
            pb_1.Message.setField(this, 9, value);
        }
        static fromObject(data: {
            record_type?: string[];
            name?: string;
            root_expression?: ReturnType<typeof KeyExpression.prototype.toObject>;
            subspace_key?: Uint8Array;
            last_modified_version?: number;
            type?: string;
            options?: ReturnType<typeof Index.Option.prototype.toObject>[];
            added_version?: number;
            unique?: boolean;
        }) {
            const message = new Index({});
            if (data.record_type != null) {
                message.record_type = data.record_type;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.root_expression != null) {
                message.root_expression = KeyExpression.fromObject(data.root_expression);
            }
            if (data.subspace_key != null) {
                message.subspace_key = data.subspace_key;
            }
            if (data.last_modified_version != null) {
                message.last_modified_version = data.last_modified_version;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.options != null) {
                message.options = data.options.map(item => Index.Option.fromObject(item));
            }
            if (data.added_version != null) {
                message.added_version = data.added_version;
            }
            if (data.unique != null) {
                message.unique = data.unique;
            }
            return message;
        }
        toObject() {
            const data: {
                record_type?: string[];
                name?: string;
                root_expression?: ReturnType<typeof KeyExpression.prototype.toObject>;
                subspace_key?: Uint8Array;
                last_modified_version?: number;
                type?: string;
                options?: ReturnType<typeof Index.Option.prototype.toObject>[];
                added_version?: number;
                unique?: boolean;
            } = {};
            if (this.record_type != null) {
                data.record_type = this.record_type;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.root_expression != null) {
                data.root_expression = this.root_expression.toObject();
            }
            if (this.subspace_key != null) {
                data.subspace_key = this.subspace_key;
            }
            if (this.last_modified_version != null) {
                data.last_modified_version = this.last_modified_version;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.options != null) {
                data.options = this.options.map((item: Index.Option) => item.toObject());
            }
            if (this.added_version != null) {
                data.added_version = this.added_version;
            }
            if (this.unique != null) {
                data.unique = this.unique;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.record_type !== undefined)
                writer.writeRepeatedString(1, this.record_type);
            if (typeof this.name === "string" && this.name.length)
                writer.writeString(2, this.name);
            if (this.root_expression !== undefined)
                writer.writeMessage(3, this.root_expression, () => this.root_expression.serialize(writer));
            if (this.subspace_key !== undefined)
                writer.writeBytes(4, this.subspace_key);
            if (this.last_modified_version !== undefined)
                writer.writeInt32(5, this.last_modified_version);
            if (typeof this.type === "string" && this.type.length)
                writer.writeString(6, this.type);
            if (this.options !== undefined)
                writer.writeRepeatedMessage(7, this.options, (item: Index.Option) => item.serialize(writer));
            if (this.added_version !== undefined)
                writer.writeInt32(8, this.added_version);
            if (this.unique !== undefined)
                writer.writeBool(9, this.unique);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Index {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Index();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.root_expression, () => message.root_expression = KeyExpression.deserialize(reader));
                        break;
                    case 4:
                        message.subspace_key = reader.readBytes();
                        break;
                    case 5:
                        message.last_modified_version = reader.readInt32();
                        break;
                    case 6:
                        message.type = reader.readString();
                        break;
                    case 7:
                        reader.readMessage(message.options, () => pb_1.Message.addToRepeatedWrapperField(message, 7, Index.Option.deserialize(reader), Index.Option));
                        break;
                    case 8:
                        message.added_version = reader.readInt32();
                        break;
                    case 9:
                        message.unique = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Index {
            return Index.deserialize(bytes);
        }
    }
    export namespace Index {
        export class Option extends pb_1.Message {
            constructor(data?: any[] | {
                key?: string;
                value?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("key" in data && data.key != undefined) {
                        this.key = data.key;
                    }
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get key() {
                return pb_1.Message.getField(this, 1) as string;
            }
            set key(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get value() {
                return pb_1.Message.getField(this, 2) as string;
            }
            set value(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                key?: string;
                value?: string;
            }) {
                const message = new Option({});
                if (data.key != null) {
                    message.key = data.key;
                }
                if (data.value != null) {
                    message.value = data.value;
                }
                return message;
            }
            toObject() {
                const data: {
                    key?: string;
                    value?: string;
                } = {};
                if (this.key != null) {
                    data.key = this.key;
                }
                if (this.value != null) {
                    data.value = this.value;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (typeof this.key === "string" && this.key.length)
                    writer.writeString(1, this.key);
                if (typeof this.value === "string" && this.value.length)
                    writer.writeString(2, this.value);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Option {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Option();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.key = reader.readString();
                            break;
                        case 2:
                            message.value = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Option {
                return Option.deserialize(bytes);
            }
        }
    }
    export class RecordType extends pb_1.Message {
        constructor(data?: any[] | {
            name?: string;
            primary_key?: KeyExpression;
            since_version?: number;
            explicit_key?: dependency_2.google.protobuf.Any;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("primary_key" in data && data.primary_key != undefined) {
                    this.primary_key = data.primary_key;
                }
                if ("since_version" in data && data.since_version != undefined) {
                    this.since_version = data.since_version;
                }
                if ("explicit_key" in data && data.explicit_key != undefined) {
                    this.explicit_key = data.explicit_key;
                }
            }
        }
        get name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get primary_key() {
            return pb_1.Message.getWrapperField(this, KeyExpression, 2) as KeyExpression;
        }
        set primary_key(value: KeyExpression) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get since_version() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set since_version(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get explicit_key() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Any, 4) as dependency_2.google.protobuf.Any;
        }
        set explicit_key(value: dependency_2.google.protobuf.Any) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        static fromObject(data: {
            name?: string;
            primary_key?: ReturnType<typeof KeyExpression.prototype.toObject>;
            since_version?: number;
            explicit_key?: ReturnType<typeof dependency_2.google.protobuf.Any.prototype.toObject>;
        }) {
            const message = new RecordType({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.primary_key != null) {
                message.primary_key = KeyExpression.fromObject(data.primary_key);
            }
            if (data.since_version != null) {
                message.since_version = data.since_version;
            }
            if (data.explicit_key != null) {
                message.explicit_key = dependency_2.google.protobuf.Any.fromObject(data.explicit_key);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                primary_key?: ReturnType<typeof KeyExpression.prototype.toObject>;
                since_version?: number;
                explicit_key?: ReturnType<typeof dependency_2.google.protobuf.Any.prototype.toObject>;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.primary_key != null) {
                data.primary_key = this.primary_key.toObject();
            }
            if (this.since_version != null) {
                data.since_version = this.since_version;
            }
            if (this.explicit_key != null) {
                data.explicit_key = this.explicit_key.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.name === "string" && this.name.length)
                writer.writeString(1, this.name);
            if (this.primary_key !== undefined)
                writer.writeMessage(2, this.primary_key, () => this.primary_key.serialize(writer));
            if (this.since_version !== undefined)
                writer.writeInt32(3, this.since_version);
            if (this.explicit_key !== undefined)
                writer.writeMessage(4, this.explicit_key, () => this.explicit_key.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RecordType {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RecordType();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.primary_key, () => message.primary_key = KeyExpression.deserialize(reader));
                        break;
                    case 3:
                        message.since_version = reader.readInt32();
                        break;
                    case 4:
                        reader.readMessage(message.explicit_key, () => message.explicit_key = dependency_2.google.protobuf.Any.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RecordType {
            return RecordType.deserialize(bytes);
        }
    }
    export class FormerIndex extends pb_1.Message {
        constructor(data?: any[] | {
            former_name?: string;
            subspace_key?: Uint8Array;
            removed_version?: number;
            added_version?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("former_name" in data && data.former_name != undefined) {
                    this.former_name = data.former_name;
                }
                if ("subspace_key" in data && data.subspace_key != undefined) {
                    this.subspace_key = data.subspace_key;
                }
                if ("removed_version" in data && data.removed_version != undefined) {
                    this.removed_version = data.removed_version;
                }
                if ("added_version" in data && data.added_version != undefined) {
                    this.added_version = data.added_version;
                }
            }
        }
        get former_name() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set former_name(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get subspace_key() {
            return pb_1.Message.getField(this, 5) as Uint8Array;
        }
        set subspace_key(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get removed_version() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set removed_version(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get added_version() {
            return pb_1.Message.getField(this, 10) as number;
        }
        set added_version(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        static fromObject(data: {
            former_name?: string;
            subspace_key?: Uint8Array;
            removed_version?: number;
            added_version?: number;
        }) {
            const message = new FormerIndex({});
            if (data.former_name != null) {
                message.former_name = data.former_name;
            }
            if (data.subspace_key != null) {
                message.subspace_key = data.subspace_key;
            }
            if (data.removed_version != null) {
                message.removed_version = data.removed_version;
            }
            if (data.added_version != null) {
                message.added_version = data.added_version;
            }
            return message;
        }
        toObject() {
            const data: {
                former_name?: string;
                subspace_key?: Uint8Array;
                removed_version?: number;
                added_version?: number;
            } = {};
            if (this.former_name != null) {
                data.former_name = this.former_name;
            }
            if (this.subspace_key != null) {
                data.subspace_key = this.subspace_key;
            }
            if (this.removed_version != null) {
                data.removed_version = this.removed_version;
            }
            if (this.added_version != null) {
                data.added_version = this.added_version;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.former_name === "string" && this.former_name.length)
                writer.writeString(3, this.former_name);
            if (this.subspace_key !== undefined)
                writer.writeBytes(5, this.subspace_key);
            if (this.removed_version !== undefined)
                writer.writeInt32(6, this.removed_version);
            if (this.added_version !== undefined)
                writer.writeInt32(10, this.added_version);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FormerIndex {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FormerIndex();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 3:
                        message.former_name = reader.readString();
                        break;
                    case 5:
                        message.subspace_key = reader.readBytes();
                        break;
                    case 6:
                        message.removed_version = reader.readInt32();
                        break;
                    case 10:
                        message.added_version = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FormerIndex {
            return FormerIndex.deserialize(bytes);
        }
    }
    export class MetaData extends pb_1.Message {
        constructor(data?: any[] | {
            record_descriptor?: dependency_1.google.protobuf.DescriptorProto;
            indexes?: Index[];
            record_types?: RecordType[];
            split_long_records?: boolean;
            version?: number;
            former_indexes?: FormerIndex[];
            store_record_versions?: boolean;
            subspace_key_counter?: number;
            uses_subspace_key_counter?: boolean;
            joined_record_types?: JoinedRecordType[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3, 6, 11], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("record_descriptor" in data && data.record_descriptor != undefined) {
                    this.record_descriptor = data.record_descriptor;
                }
                if ("indexes" in data && data.indexes != undefined) {
                    this.indexes = data.indexes;
                }
                if ("record_types" in data && data.record_types != undefined) {
                    this.record_types = data.record_types;
                }
                if ("split_long_records" in data && data.split_long_records != undefined) {
                    this.split_long_records = data.split_long_records;
                }
                if ("version" in data && data.version != undefined) {
                    this.version = data.version;
                }
                if ("former_indexes" in data && data.former_indexes != undefined) {
                    this.former_indexes = data.former_indexes;
                }
                if ("store_record_versions" in data && data.store_record_versions != undefined) {
                    this.store_record_versions = data.store_record_versions;
                }
                if ("subspace_key_counter" in data && data.subspace_key_counter != undefined) {
                    this.subspace_key_counter = data.subspace_key_counter;
                }
                if ("uses_subspace_key_counter" in data && data.uses_subspace_key_counter != undefined) {
                    this.uses_subspace_key_counter = data.uses_subspace_key_counter;
                }
                if ("joined_record_types" in data && data.joined_record_types != undefined) {
                    this.joined_record_types = data.joined_record_types;
                }
            }
        }
        get record_descriptor() {
            return pb_1.Message.getWrapperField(this, dependency_1.google.protobuf.DescriptorProto, 1) as dependency_1.google.protobuf.DescriptorProto;
        }
        set record_descriptor(value: dependency_1.google.protobuf.DescriptorProto) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get indexes() {
            return pb_1.Message.getRepeatedWrapperField(this, Index, 2) as Index[];
        }
        set indexes(value: Index[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get record_types() {
            return pb_1.Message.getRepeatedWrapperField(this, RecordType, 3) as RecordType[];
        }
        set record_types(value: RecordType[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get split_long_records() {
            return pb_1.Message.getField(this, 4) as boolean;
        }
        set split_long_records(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        get version() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set version(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get former_indexes() {
            return pb_1.Message.getRepeatedWrapperField(this, FormerIndex, 6) as FormerIndex[];
        }
        set former_indexes(value: FormerIndex[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get store_record_versions() {
            return pb_1.Message.getField(this, 7) as boolean;
        }
        set store_record_versions(value: boolean) {
            pb_1.Message.setField(this, 7, value);
        }
        get subspace_key_counter() {
            return pb_1.Message.getField(this, 9) as number;
        }
        set subspace_key_counter(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        get uses_subspace_key_counter() {
            return pb_1.Message.getField(this, 10) as boolean;
        }
        set uses_subspace_key_counter(value: boolean) {
            pb_1.Message.setField(this, 10, value);
        }
        get joined_record_types() {
            return pb_1.Message.getRepeatedWrapperField(this, JoinedRecordType, 11) as JoinedRecordType[];
        }
        set joined_record_types(value: JoinedRecordType[]) {
            pb_1.Message.setRepeatedWrapperField(this, 11, value);
        }
        static fromObject(data: {
            record_descriptor?: ReturnType<typeof dependency_1.google.protobuf.DescriptorProto.prototype.toObject>;
            indexes?: ReturnType<typeof Index.prototype.toObject>[];
            record_types?: ReturnType<typeof RecordType.prototype.toObject>[];
            split_long_records?: boolean;
            version?: number;
            former_indexes?: ReturnType<typeof FormerIndex.prototype.toObject>[];
            store_record_versions?: boolean;
            subspace_key_counter?: number;
            uses_subspace_key_counter?: boolean;
            joined_record_types?: ReturnType<typeof JoinedRecordType.prototype.toObject>[];
        }) {
            const message = new MetaData({});
            if (data.record_descriptor != null) {
                message.record_descriptor = dependency_1.google.protobuf.DescriptorProto.fromObject(data.record_descriptor);
            }
            if (data.indexes != null) {
                message.indexes = data.indexes.map(item => Index.fromObject(item));
            }
            if (data.record_types != null) {
                message.record_types = data.record_types.map(item => RecordType.fromObject(item));
            }
            if (data.split_long_records != null) {
                message.split_long_records = data.split_long_records;
            }
            if (data.version != null) {
                message.version = data.version;
            }
            if (data.former_indexes != null) {
                message.former_indexes = data.former_indexes.map(item => FormerIndex.fromObject(item));
            }
            if (data.store_record_versions != null) {
                message.store_record_versions = data.store_record_versions;
            }
            if (data.subspace_key_counter != null) {
                message.subspace_key_counter = data.subspace_key_counter;
            }
            if (data.uses_subspace_key_counter != null) {
                message.uses_subspace_key_counter = data.uses_subspace_key_counter;
            }
            if (data.joined_record_types != null) {
                message.joined_record_types = data.joined_record_types.map(item => JoinedRecordType.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                record_descriptor?: ReturnType<typeof dependency_1.google.protobuf.DescriptorProto.prototype.toObject>;
                indexes?: ReturnType<typeof Index.prototype.toObject>[];
                record_types?: ReturnType<typeof RecordType.prototype.toObject>[];
                split_long_records?: boolean;
                version?: number;
                former_indexes?: ReturnType<typeof FormerIndex.prototype.toObject>[];
                store_record_versions?: boolean;
                subspace_key_counter?: number;
                uses_subspace_key_counter?: boolean;
                joined_record_types?: ReturnType<typeof JoinedRecordType.prototype.toObject>[];
            } = {};
            if (this.record_descriptor != null) {
                data.record_descriptor = this.record_descriptor.toObject();
            }
            if (this.indexes != null) {
                data.indexes = this.indexes.map((item: Index) => item.toObject());
            }
            if (this.record_types != null) {
                data.record_types = this.record_types.map((item: RecordType) => item.toObject());
            }
            if (this.split_long_records != null) {
                data.split_long_records = this.split_long_records;
            }
            if (this.version != null) {
                data.version = this.version;
            }
            if (this.former_indexes != null) {
                data.former_indexes = this.former_indexes.map((item: FormerIndex) => item.toObject());
            }
            if (this.store_record_versions != null) {
                data.store_record_versions = this.store_record_versions;
            }
            if (this.subspace_key_counter != null) {
                data.subspace_key_counter = this.subspace_key_counter;
            }
            if (this.uses_subspace_key_counter != null) {
                data.uses_subspace_key_counter = this.uses_subspace_key_counter;
            }
            if (this.joined_record_types != null) {
                data.joined_record_types = this.joined_record_types.map((item: JoinedRecordType) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.record_descriptor !== undefined)
                writer.writeMessage(1, this.record_descriptor, () => this.record_descriptor.serialize(writer));
            if (this.indexes !== undefined)
                writer.writeRepeatedMessage(2, this.indexes, (item: Index) => item.serialize(writer));
            if (this.record_types !== undefined)
                writer.writeRepeatedMessage(3, this.record_types, (item: RecordType) => item.serialize(writer));
            if (this.split_long_records !== undefined)
                writer.writeBool(4, this.split_long_records);
            if (this.version !== undefined)
                writer.writeInt32(5, this.version);
            if (this.former_indexes !== undefined)
                writer.writeRepeatedMessage(6, this.former_indexes, (item: FormerIndex) => item.serialize(writer));
            if (this.store_record_versions !== undefined)
                writer.writeBool(7, this.store_record_versions);
            if (this.subspace_key_counter !== undefined)
                writer.writeInt64(9, this.subspace_key_counter);
            if (this.uses_subspace_key_counter !== undefined)
                writer.writeBool(10, this.uses_subspace_key_counter);
            if (this.joined_record_types !== undefined)
                writer.writeRepeatedMessage(11, this.joined_record_types, (item: JoinedRecordType) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MetaData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MetaData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.record_descriptor, () => message.record_descriptor = dependency_1.google.protobuf.DescriptorProto.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.indexes, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Index.deserialize(reader), Index));
                        break;
                    case 3:
                        reader.readMessage(message.record_types, () => pb_1.Message.addToRepeatedWrapperField(message, 3, RecordType.deserialize(reader), RecordType));
                        break;
                    case 4:
                        message.split_long_records = reader.readBool();
                        break;
                    case 5:
                        message.version = reader.readInt32();
                        break;
                    case 6:
                        reader.readMessage(message.former_indexes, () => pb_1.Message.addToRepeatedWrapperField(message, 6, FormerIndex.deserialize(reader), FormerIndex));
                        break;
                    case 7:
                        message.store_record_versions = reader.readBool();
                        break;
                    case 9:
                        message.subspace_key_counter = reader.readInt64();
                        break;
                    case 10:
                        message.uses_subspace_key_counter = reader.readBool();
                        break;
                    case 11:
                        reader.readMessage(message.joined_record_types, () => pb_1.Message.addToRepeatedWrapperField(message, 11, JoinedRecordType.deserialize(reader), JoinedRecordType));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MetaData {
            return MetaData.deserialize(bytes);
        }
    }
    export class Then extends pb_1.Message {
        constructor(data?: any[] | {
            child?: KeyExpression[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("child" in data && data.child != undefined) {
                    this.child = data.child;
                }
            }
        }
        get child() {
            return pb_1.Message.getRepeatedWrapperField(this, KeyExpression, 1) as KeyExpression[];
        }
        set child(value: KeyExpression[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            child?: ReturnType<typeof KeyExpression.prototype.toObject>[];
        }) {
            const message = new Then({});
            if (data.child != null) {
                message.child = data.child.map(item => KeyExpression.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                child?: ReturnType<typeof KeyExpression.prototype.toObject>[];
            } = {};
            if (this.child != null) {
                data.child = this.child.map((item: KeyExpression) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.child !== undefined)
                writer.writeRepeatedMessage(1, this.child, (item: KeyExpression) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Then {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Then();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.child, () => pb_1.Message.addToRepeatedWrapperField(message, 1, KeyExpression.deserialize(reader), KeyExpression));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Then {
            return Then.deserialize(bytes);
        }
    }
    export class List extends pb_1.Message {
        constructor(data?: any[] | {
            child?: KeyExpression[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("child" in data && data.child != undefined) {
                    this.child = data.child;
                }
            }
        }
        get child() {
            return pb_1.Message.getRepeatedWrapperField(this, KeyExpression, 1) as KeyExpression[];
        }
        set child(value: KeyExpression[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            child?: ReturnType<typeof KeyExpression.prototype.toObject>[];
        }) {
            const message = new List({});
            if (data.child != null) {
                message.child = data.child.map(item => KeyExpression.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                child?: ReturnType<typeof KeyExpression.prototype.toObject>[];
            } = {};
            if (this.child != null) {
                data.child = this.child.map((item: KeyExpression) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.child !== undefined)
                writer.writeRepeatedMessage(1, this.child, (item: KeyExpression) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): List {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new List();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.child, () => pb_1.Message.addToRepeatedWrapperField(message, 1, KeyExpression.deserialize(reader), KeyExpression));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): List {
            return List.deserialize(bytes);
        }
    }
    export class Field extends pb_1.Message {
        constructor(data?: any[] | {
            field_name?: string;
            fan_type?: Field.FanType;
            nullInterpretation?: Field.NullInterpretation;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("field_name" in data && data.field_name != undefined) {
                    this.field_name = data.field_name;
                }
                if ("fan_type" in data && data.fan_type != undefined) {
                    this.fan_type = data.fan_type;
                }
                if ("nullInterpretation" in data && data.nullInterpretation != undefined) {
                    this.nullInterpretation = data.nullInterpretation;
                }
            }
        }
        get field_name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set field_name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get fan_type() {
            return pb_1.Message.getField(this, 2) as Field.FanType;
        }
        set fan_type(value: Field.FanType) {
            pb_1.Message.setField(this, 2, value);
        }
        get nullInterpretation() {
            return pb_1.Message.getField(this, 3) as Field.NullInterpretation;
        }
        set nullInterpretation(value: Field.NullInterpretation) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            field_name?: string;
            fan_type?: Field.FanType;
            nullInterpretation?: Field.NullInterpretation;
        }) {
            const message = new Field({});
            if (data.field_name != null) {
                message.field_name = data.field_name;
            }
            if (data.fan_type != null) {
                message.fan_type = data.fan_type;
            }
            if (data.nullInterpretation != null) {
                message.nullInterpretation = data.nullInterpretation;
            }
            return message;
        }
        toObject() {
            const data: {
                field_name?: string;
                fan_type?: Field.FanType;
                nullInterpretation?: Field.NullInterpretation;
            } = {};
            if (this.field_name != null) {
                data.field_name = this.field_name;
            }
            if (this.fan_type != null) {
                data.fan_type = this.fan_type;
            }
            if (this.nullInterpretation != null) {
                data.nullInterpretation = this.nullInterpretation;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.field_name === "string" && this.field_name.length)
                writer.writeString(1, this.field_name);
            if (this.fan_type !== undefined)
                writer.writeEnum(2, this.fan_type);
            if (this.nullInterpretation !== undefined)
                writer.writeEnum(3, this.nullInterpretation);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Field {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Field();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.field_name = reader.readString();
                        break;
                    case 2:
                        message.fan_type = reader.readEnum();
                        break;
                    case 3:
                        message.nullInterpretation = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Field {
            return Field.deserialize(bytes);
        }
    }
    export namespace Field {
        export enum FanType {
            FAN_ERROR = 0,
            SCALAR = 1,
            FAN_OUT = 2,
            CONCATENATE = 3
        }
        export enum NullInterpretation {
            NULL_ERROR = 0,
            NOT_UNIQUE = 1,
            UNIQUE = 2,
            NOT_NULL = 3
        }
    }
    export class Nesting extends pb_1.Message {
        constructor(data?: any[] | {
            parent?: Field;
            child?: KeyExpression;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("parent" in data && data.parent != undefined) {
                    this.parent = data.parent;
                }
                if ("child" in data && data.child != undefined) {
                    this.child = data.child;
                }
            }
        }
        get parent() {
            return pb_1.Message.getWrapperField(this, Field, 1) as Field;
        }
        set parent(value: Field) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get child() {
            return pb_1.Message.getWrapperField(this, KeyExpression, 2) as KeyExpression;
        }
        set child(value: KeyExpression) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        static fromObject(data: {
            parent?: ReturnType<typeof Field.prototype.toObject>;
            child?: ReturnType<typeof KeyExpression.prototype.toObject>;
        }) {
            const message = new Nesting({});
            if (data.parent != null) {
                message.parent = Field.fromObject(data.parent);
            }
            if (data.child != null) {
                message.child = KeyExpression.fromObject(data.child);
            }
            return message;
        }
        toObject() {
            const data: {
                parent?: ReturnType<typeof Field.prototype.toObject>;
                child?: ReturnType<typeof KeyExpression.prototype.toObject>;
            } = {};
            if (this.parent != null) {
                data.parent = this.parent.toObject();
            }
            if (this.child != null) {
                data.child = this.child.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.parent !== undefined)
                writer.writeMessage(1, this.parent, () => this.parent.serialize(writer));
            if (this.child !== undefined)
                writer.writeMessage(2, this.child, () => this.child.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Nesting {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Nesting();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.parent, () => message.parent = Field.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.child, () => message.child = KeyExpression.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Nesting {
            return Nesting.deserialize(bytes);
        }
    }
    export class Grouping extends pb_1.Message {
        constructor(data?: any[] | {
            whole_key?: KeyExpression;
            grouped_count?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("whole_key" in data && data.whole_key != undefined) {
                    this.whole_key = data.whole_key;
                }
                if ("grouped_count" in data && data.grouped_count != undefined) {
                    this.grouped_count = data.grouped_count;
                }
            }
        }
        get whole_key() {
            return pb_1.Message.getWrapperField(this, KeyExpression, 1) as KeyExpression;
        }
        set whole_key(value: KeyExpression) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get grouped_count() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set grouped_count(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            whole_key?: ReturnType<typeof KeyExpression.prototype.toObject>;
            grouped_count?: number;
        }) {
            const message = new Grouping({});
            if (data.whole_key != null) {
                message.whole_key = KeyExpression.fromObject(data.whole_key);
            }
            if (data.grouped_count != null) {
                message.grouped_count = data.grouped_count;
            }
            return message;
        }
        toObject() {
            const data: {
                whole_key?: ReturnType<typeof KeyExpression.prototype.toObject>;
                grouped_count?: number;
            } = {};
            if (this.whole_key != null) {
                data.whole_key = this.whole_key.toObject();
            }
            if (this.grouped_count != null) {
                data.grouped_count = this.grouped_count;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.whole_key !== undefined)
                writer.writeMessage(1, this.whole_key, () => this.whole_key.serialize(writer));
            if (this.grouped_count !== undefined)
                writer.writeInt32(3, this.grouped_count);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Grouping {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Grouping();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.whole_key, () => message.whole_key = KeyExpression.deserialize(reader));
                        break;
                    case 3:
                        message.grouped_count = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Grouping {
            return Grouping.deserialize(bytes);
        }
    }
    export class KeyWithValue extends pb_1.Message {
        constructor(data?: any[] | {
            inner_key?: KeyExpression;
            split_point?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("inner_key" in data && data.inner_key != undefined) {
                    this.inner_key = data.inner_key;
                }
                if ("split_point" in data && data.split_point != undefined) {
                    this.split_point = data.split_point;
                }
            }
        }
        get inner_key() {
            return pb_1.Message.getWrapperField(this, KeyExpression, 1) as KeyExpression;
        }
        set inner_key(value: KeyExpression) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get split_point() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set split_point(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            inner_key?: ReturnType<typeof KeyExpression.prototype.toObject>;
            split_point?: number;
        }) {
            const message = new KeyWithValue({});
            if (data.inner_key != null) {
                message.inner_key = KeyExpression.fromObject(data.inner_key);
            }
            if (data.split_point != null) {
                message.split_point = data.split_point;
            }
            return message;
        }
        toObject() {
            const data: {
                inner_key?: ReturnType<typeof KeyExpression.prototype.toObject>;
                split_point?: number;
            } = {};
            if (this.inner_key != null) {
                data.inner_key = this.inner_key.toObject();
            }
            if (this.split_point != null) {
                data.split_point = this.split_point;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.inner_key !== undefined)
                writer.writeMessage(1, this.inner_key, () => this.inner_key.serialize(writer));
            if (this.split_point !== undefined)
                writer.writeInt32(2, this.split_point);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): KeyWithValue {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new KeyWithValue();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.inner_key, () => message.inner_key = KeyExpression.deserialize(reader));
                        break;
                    case 2:
                        message.split_point = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): KeyWithValue {
            return KeyWithValue.deserialize(bytes);
        }
    }
    export class Split extends pb_1.Message {
        constructor(data?: any[] | {
            joined?: KeyExpression;
            split_size?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("joined" in data && data.joined != undefined) {
                    this.joined = data.joined;
                }
                if ("split_size" in data && data.split_size != undefined) {
                    this.split_size = data.split_size;
                }
            }
        }
        get joined() {
            return pb_1.Message.getWrapperField(this, KeyExpression, 1) as KeyExpression;
        }
        set joined(value: KeyExpression) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get split_size() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set split_size(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            joined?: ReturnType<typeof KeyExpression.prototype.toObject>;
            split_size?: number;
        }) {
            const message = new Split({});
            if (data.joined != null) {
                message.joined = KeyExpression.fromObject(data.joined);
            }
            if (data.split_size != null) {
                message.split_size = data.split_size;
            }
            return message;
        }
        toObject() {
            const data: {
                joined?: ReturnType<typeof KeyExpression.prototype.toObject>;
                split_size?: number;
            } = {};
            if (this.joined != null) {
                data.joined = this.joined.toObject();
            }
            if (this.split_size != null) {
                data.split_size = this.split_size;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.joined !== undefined)
                writer.writeMessage(1, this.joined, () => this.joined.serialize(writer));
            if (this.split_size !== undefined)
                writer.writeInt32(2, this.split_size);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Split {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Split();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.joined, () => message.joined = KeyExpression.deserialize(reader));
                        break;
                    case 2:
                        message.split_size = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Split {
            return Split.deserialize(bytes);
        }
    }
    export class Empty extends pb_1.Message {
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}) {
            const message = new Empty({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Empty {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Empty();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Empty {
            return Empty.deserialize(bytes);
        }
    }
    export class Version extends pb_1.Message {
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}) {
            const message = new Version({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Version {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Version();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Version {
            return Version.deserialize(bytes);
        }
    }
    export class RecordTypeKey extends pb_1.Message {
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}) {
            const message = new RecordTypeKey({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RecordTypeKey {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RecordTypeKey();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RecordTypeKey {
            return RecordTypeKey.deserialize(bytes);
        }
    }
    export class Function extends pb_1.Message {
        constructor(data?: any[] | {
            name?: string;
            arguments?: KeyExpression;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("arguments" in data && data.arguments != undefined) {
                    this.arguments = data.arguments;
                }
            }
        }
        get name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get arguments() {
            return pb_1.Message.getWrapperField(this, KeyExpression, 2) as KeyExpression;
        }
        set arguments(value: KeyExpression) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        static fromObject(data: {
            name?: string;
            arguments?: ReturnType<typeof KeyExpression.prototype.toObject>;
        }) {
            const message = new Function({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.arguments != null) {
                message.arguments = KeyExpression.fromObject(data.arguments);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                arguments?: ReturnType<typeof KeyExpression.prototype.toObject>;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.arguments != null) {
                data.arguments = this.arguments.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.name === "string" && this.name.length)
                writer.writeString(1, this.name);
            if (this.arguments !== undefined)
                writer.writeMessage(2, this.arguments, () => this.arguments.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Function {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Function();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.arguments, () => message.arguments = KeyExpression.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Function {
            return Function.deserialize(bytes);
        }
    }
    export class KeyExpression extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            then?: Then;
            nesting?: never;
            field?: never;
            grouping?: never;
            empty?: never;
            split?: never;
            version?: never;
            value?: never;
            function?: never;
            key_with_value?: never;
            record_type_key?: never;
            list?: never;
        } | {
            then?: never;
            nesting?: Nesting;
            field?: never;
            grouping?: never;
            empty?: never;
            split?: never;
            version?: never;
            value?: never;
            function?: never;
            key_with_value?: never;
            record_type_key?: never;
            list?: never;
        } | {
            then?: never;
            nesting?: never;
            field?: Field;
            grouping?: never;
            empty?: never;
            split?: never;
            version?: never;
            value?: never;
            function?: never;
            key_with_value?: never;
            record_type_key?: never;
            list?: never;
        } | {
            then?: never;
            nesting?: never;
            field?: never;
            grouping?: Grouping;
            empty?: never;
            split?: never;
            version?: never;
            value?: never;
            function?: never;
            key_with_value?: never;
            record_type_key?: never;
            list?: never;
        } | {
            then?: never;
            nesting?: never;
            field?: never;
            grouping?: never;
            empty?: Empty;
            split?: never;
            version?: never;
            value?: never;
            function?: never;
            key_with_value?: never;
            record_type_key?: never;
            list?: never;
        } | {
            then?: never;
            nesting?: never;
            field?: never;
            grouping?: never;
            empty?: never;
            split?: Split;
            version?: never;
            value?: never;
            function?: never;
            key_with_value?: never;
            record_type_key?: never;
            list?: never;
        } | {
            then?: never;
            nesting?: never;
            field?: never;
            grouping?: never;
            empty?: never;
            split?: never;
            version?: Version;
            value?: never;
            function?: never;
            key_with_value?: never;
            record_type_key?: never;
            list?: never;
        } | {
            then?: never;
            nesting?: never;
            field?: never;
            grouping?: never;
            empty?: never;
            split?: never;
            version?: never;
            value?: dependency_2.google.protobuf.Any;
            function?: never;
            key_with_value?: never;
            record_type_key?: never;
            list?: never;
        } | {
            then?: never;
            nesting?: never;
            field?: never;
            grouping?: never;
            empty?: never;
            split?: never;
            version?: never;
            value?: never;
            function?: Function;
            key_with_value?: never;
            record_type_key?: never;
            list?: never;
        } | {
            then?: never;
            nesting?: never;
            field?: never;
            grouping?: never;
            empty?: never;
            split?: never;
            version?: never;
            value?: never;
            function?: never;
            key_with_value?: KeyWithValue;
            record_type_key?: never;
            list?: never;
        } | {
            then?: never;
            nesting?: never;
            field?: never;
            grouping?: never;
            empty?: never;
            split?: never;
            version?: never;
            value?: never;
            function?: never;
            key_with_value?: never;
            record_type_key?: RecordTypeKey;
            list?: never;
        } | {
            then?: never;
            nesting?: never;
            field?: never;
            grouping?: never;
            empty?: never;
            split?: never;
            version?: never;
            value?: never;
            function?: never;
            key_with_value?: never;
            record_type_key?: never;
            list?: List;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("then" in data && data.then != undefined) {
                    this.then = data.then;
                }
                if ("nesting" in data && data.nesting != undefined) {
                    this.nesting = data.nesting;
                }
                if ("field" in data && data.field != undefined) {
                    this.field = data.field;
                }
                if ("grouping" in data && data.grouping != undefined) {
                    this.grouping = data.grouping;
                }
                if ("empty" in data && data.empty != undefined) {
                    this.empty = data.empty;
                }
                if ("split" in data && data.split != undefined) {
                    this.split = data.split;
                }
                if ("version" in data && data.version != undefined) {
                    this.version = data.version;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("function" in data && data.function != undefined) {
                    this.function = data.function;
                }
                if ("key_with_value" in data && data.key_with_value != undefined) {
                    this.key_with_value = data.key_with_value;
                }
                if ("record_type_key" in data && data.record_type_key != undefined) {
                    this.record_type_key = data.record_type_key;
                }
                if ("list" in data && data.list != undefined) {
                    this.list = data.list;
                }
            }
        }
        get then() {
            return pb_1.Message.getWrapperField(this, Then, 1) as Then;
        }
        set then(value: Then) {
            pb_1.Message.setOneofWrapperField(this, 1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], value);
        }
        get nesting() {
            return pb_1.Message.getWrapperField(this, Nesting, 2) as Nesting;
        }
        set nesting(value: Nesting) {
            pb_1.Message.setOneofWrapperField(this, 2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], value);
        }
        get field() {
            return pb_1.Message.getWrapperField(this, Field, 3) as Field;
        }
        set field(value: Field) {
            pb_1.Message.setOneofWrapperField(this, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], value);
        }
        get grouping() {
            return pb_1.Message.getWrapperField(this, Grouping, 4) as Grouping;
        }
        set grouping(value: Grouping) {
            pb_1.Message.setOneofWrapperField(this, 4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], value);
        }
        get empty() {
            return pb_1.Message.getWrapperField(this, Empty, 5) as Empty;
        }
        set empty(value: Empty) {
            pb_1.Message.setOneofWrapperField(this, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], value);
        }
        get split() {
            return pb_1.Message.getWrapperField(this, Split, 6) as Split;
        }
        set split(value: Split) {
            pb_1.Message.setOneofWrapperField(this, 6, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], value);
        }
        get version() {
            return pb_1.Message.getWrapperField(this, Version, 7) as Version;
        }
        set version(value: Version) {
            pb_1.Message.setOneofWrapperField(this, 7, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], value);
        }
        get value() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Any, 8) as dependency_2.google.protobuf.Any;
        }
        set value(value: dependency_2.google.protobuf.Any) {
            pb_1.Message.setOneofWrapperField(this, 8, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], value);
        }
        get function() {
            return pb_1.Message.getWrapperField(this, Function, 9) as Function;
        }
        set function(value: Function) {
            pb_1.Message.setOneofWrapperField(this, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], value);
        }
        get key_with_value() {
            return pb_1.Message.getWrapperField(this, KeyWithValue, 10) as KeyWithValue;
        }
        set key_with_value(value: KeyWithValue) {
            pb_1.Message.setOneofWrapperField(this, 10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], value);
        }
        get record_type_key() {
            return pb_1.Message.getWrapperField(this, RecordTypeKey, 11) as RecordTypeKey;
        }
        set record_type_key(value: RecordTypeKey) {
            pb_1.Message.setOneofWrapperField(this, 11, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], value);
        }
        get list() {
            return pb_1.Message.getWrapperField(this, List, 12) as List;
        }
        set list(value: List) {
            pb_1.Message.setOneofWrapperField(this, 12, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], value);
        }
        get expression() {
            const cases: {
                [index: number]: "none" | "then" | "nesting" | "field" | "grouping" | "empty" | "split" | "version" | "value" | "function" | "key_with_value" | "record_type_key" | "list";
            } = {
                0: "none",
                1: "then",
                2: "nesting",
                3: "field",
                4: "grouping",
                5: "empty",
                6: "split",
                7: "version",
                8: "value",
                9: "function",
                10: "key_with_value",
                11: "record_type_key",
                12: "list"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])];
        }
        static fromObject(data: {
            then?: ReturnType<typeof Then.prototype.toObject>;
            nesting?: ReturnType<typeof Nesting.prototype.toObject>;
            field?: ReturnType<typeof Field.prototype.toObject>;
            grouping?: ReturnType<typeof Grouping.prototype.toObject>;
            empty?: ReturnType<typeof Empty.prototype.toObject>;
            split?: ReturnType<typeof Split.prototype.toObject>;
            version?: ReturnType<typeof Version.prototype.toObject>;
            value?: ReturnType<typeof dependency_2.google.protobuf.Any.prototype.toObject>;
            function?: ReturnType<typeof Function.prototype.toObject>;
            key_with_value?: ReturnType<typeof KeyWithValue.prototype.toObject>;
            record_type_key?: ReturnType<typeof RecordTypeKey.prototype.toObject>;
            list?: ReturnType<typeof List.prototype.toObject>;
        }) {
            const message = new KeyExpression({});
            if (data.then != null) {
                message.then = Then.fromObject(data.then);
            }
            if (data.nesting != null) {
                message.nesting = Nesting.fromObject(data.nesting);
            }
            if (data.field != null) {
                message.field = Field.fromObject(data.field);
            }
            if (data.grouping != null) {
                message.grouping = Grouping.fromObject(data.grouping);
            }
            if (data.empty != null) {
                message.empty = Empty.fromObject(data.empty);
            }
            if (data.split != null) {
                message.split = Split.fromObject(data.split);
            }
            if (data.version != null) {
                message.version = Version.fromObject(data.version);
            }
            if (data.value != null) {
                message.value = dependency_2.google.protobuf.Any.fromObject(data.value);
            }
            if (data.function != null) {
                message.function = Function.fromObject(data.function);
            }
            if (data.key_with_value != null) {
                message.key_with_value = KeyWithValue.fromObject(data.key_with_value);
            }
            if (data.record_type_key != null) {
                message.record_type_key = RecordTypeKey.fromObject(data.record_type_key);
            }
            if (data.list != null) {
                message.list = List.fromObject(data.list);
            }
            return message;
        }
        toObject() {
            const data: {
                then?: ReturnType<typeof Then.prototype.toObject>;
                nesting?: ReturnType<typeof Nesting.prototype.toObject>;
                field?: ReturnType<typeof Field.prototype.toObject>;
                grouping?: ReturnType<typeof Grouping.prototype.toObject>;
                empty?: ReturnType<typeof Empty.prototype.toObject>;
                split?: ReturnType<typeof Split.prototype.toObject>;
                version?: ReturnType<typeof Version.prototype.toObject>;
                value?: ReturnType<typeof dependency_2.google.protobuf.Any.prototype.toObject>;
                function?: ReturnType<typeof Function.prototype.toObject>;
                key_with_value?: ReturnType<typeof KeyWithValue.prototype.toObject>;
                record_type_key?: ReturnType<typeof RecordTypeKey.prototype.toObject>;
                list?: ReturnType<typeof List.prototype.toObject>;
            } = {};
            if (this.then != null) {
                data.then = this.then.toObject();
            }
            if (this.nesting != null) {
                data.nesting = this.nesting.toObject();
            }
            if (this.field != null) {
                data.field = this.field.toObject();
            }
            if (this.grouping != null) {
                data.grouping = this.grouping.toObject();
            }
            if (this.empty != null) {
                data.empty = this.empty.toObject();
            }
            if (this.split != null) {
                data.split = this.split.toObject();
            }
            if (this.version != null) {
                data.version = this.version.toObject();
            }
            if (this.value != null) {
                data.value = this.value.toObject();
            }
            if (this.function != null) {
                data.function = this.function.toObject();
            }
            if (this.key_with_value != null) {
                data.key_with_value = this.key_with_value.toObject();
            }
            if (this.record_type_key != null) {
                data.record_type_key = this.record_type_key.toObject();
            }
            if (this.list != null) {
                data.list = this.list.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.then !== undefined)
                writer.writeMessage(1, this.then, () => this.then.serialize(writer));
            if (this.nesting !== undefined)
                writer.writeMessage(2, this.nesting, () => this.nesting.serialize(writer));
            if (this.field !== undefined)
                writer.writeMessage(3, this.field, () => this.field.serialize(writer));
            if (this.grouping !== undefined)
                writer.writeMessage(4, this.grouping, () => this.grouping.serialize(writer));
            if (this.empty !== undefined)
                writer.writeMessage(5, this.empty, () => this.empty.serialize(writer));
            if (this.split !== undefined)
                writer.writeMessage(6, this.split, () => this.split.serialize(writer));
            if (this.version !== undefined)
                writer.writeMessage(7, this.version, () => this.version.serialize(writer));
            if (this.value !== undefined)
                writer.writeMessage(8, this.value, () => this.value.serialize(writer));
            if (this.function !== undefined)
                writer.writeMessage(9, this.function, () => this.function.serialize(writer));
            if (this.key_with_value !== undefined)
                writer.writeMessage(10, this.key_with_value, () => this.key_with_value.serialize(writer));
            if (this.record_type_key !== undefined)
                writer.writeMessage(11, this.record_type_key, () => this.record_type_key.serialize(writer));
            if (this.list !== undefined)
                writer.writeMessage(12, this.list, () => this.list.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): KeyExpression {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new KeyExpression();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.then, () => message.then = Then.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.nesting, () => message.nesting = Nesting.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.field, () => message.field = Field.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.grouping, () => message.grouping = Grouping.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.empty, () => message.empty = Empty.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.split, () => message.split = Split.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.version, () => message.version = Version.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.value, () => message.value = dependency_2.google.protobuf.Any.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.function, () => message.function = Function.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.key_with_value, () => message.key_with_value = KeyWithValue.deserialize(reader));
                        break;
                    case 11:
                        reader.readMessage(message.record_type_key, () => message.record_type_key = RecordTypeKey.deserialize(reader));
                        break;
                    case 12:
                        reader.readMessage(message.list, () => message.list = List.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): KeyExpression {
            return KeyExpression.deserialize(bytes);
        }
    }
    export class JoinedRecordType extends pb_1.Message {
        constructor(data?: any[] | {
            name?: string;
            record_type_key?: dependency_2.google.protobuf.Any;
            join_constituents?: JoinedRecordType.JoinConstituent[];
            joins?: JoinedRecordType.Join[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [10, 11], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("record_type_key" in data && data.record_type_key != undefined) {
                    this.record_type_key = data.record_type_key;
                }
                if ("join_constituents" in data && data.join_constituents != undefined) {
                    this.join_constituents = data.join_constituents;
                }
                if ("joins" in data && data.joins != undefined) {
                    this.joins = data.joins;
                }
            }
        }
        get name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get record_type_key() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Any, 4) as dependency_2.google.protobuf.Any;
        }
        set record_type_key(value: dependency_2.google.protobuf.Any) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get join_constituents() {
            return pb_1.Message.getRepeatedWrapperField(this, JoinedRecordType.JoinConstituent, 10) as JoinedRecordType.JoinConstituent[];
        }
        set join_constituents(value: JoinedRecordType.JoinConstituent[]) {
            pb_1.Message.setRepeatedWrapperField(this, 10, value);
        }
        get joins() {
            return pb_1.Message.getRepeatedWrapperField(this, JoinedRecordType.Join, 11) as JoinedRecordType.Join[];
        }
        set joins(value: JoinedRecordType.Join[]) {
            pb_1.Message.setRepeatedWrapperField(this, 11, value);
        }
        static fromObject(data: {
            name?: string;
            record_type_key?: ReturnType<typeof dependency_2.google.protobuf.Any.prototype.toObject>;
            join_constituents?: ReturnType<typeof JoinedRecordType.JoinConstituent.prototype.toObject>[];
            joins?: ReturnType<typeof JoinedRecordType.Join.prototype.toObject>[];
        }) {
            const message = new JoinedRecordType({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.record_type_key != null) {
                message.record_type_key = dependency_2.google.protobuf.Any.fromObject(data.record_type_key);
            }
            if (data.join_constituents != null) {
                message.join_constituents = data.join_constituents.map(item => JoinedRecordType.JoinConstituent.fromObject(item));
            }
            if (data.joins != null) {
                message.joins = data.joins.map(item => JoinedRecordType.Join.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                record_type_key?: ReturnType<typeof dependency_2.google.protobuf.Any.prototype.toObject>;
                join_constituents?: ReturnType<typeof JoinedRecordType.JoinConstituent.prototype.toObject>[];
                joins?: ReturnType<typeof JoinedRecordType.Join.prototype.toObject>[];
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.record_type_key != null) {
                data.record_type_key = this.record_type_key.toObject();
            }
            if (this.join_constituents != null) {
                data.join_constituents = this.join_constituents.map((item: JoinedRecordType.JoinConstituent) => item.toObject());
            }
            if (this.joins != null) {
                data.joins = this.joins.map((item: JoinedRecordType.Join) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.name === "string" && this.name.length)
                writer.writeString(1, this.name);
            if (this.record_type_key !== undefined)
                writer.writeMessage(4, this.record_type_key, () => this.record_type_key.serialize(writer));
            if (this.join_constituents !== undefined)
                writer.writeRepeatedMessage(10, this.join_constituents, (item: JoinedRecordType.JoinConstituent) => item.serialize(writer));
            if (this.joins !== undefined)
                writer.writeRepeatedMessage(11, this.joins, (item: JoinedRecordType.Join) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): JoinedRecordType {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new JoinedRecordType();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.record_type_key, () => message.record_type_key = dependency_2.google.protobuf.Any.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.join_constituents, () => pb_1.Message.addToRepeatedWrapperField(message, 10, JoinedRecordType.JoinConstituent.deserialize(reader), JoinedRecordType.JoinConstituent));
                        break;
                    case 11:
                        reader.readMessage(message.joins, () => pb_1.Message.addToRepeatedWrapperField(message, 11, JoinedRecordType.Join.deserialize(reader), JoinedRecordType.Join));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): JoinedRecordType {
            return JoinedRecordType.deserialize(bytes);
        }
    }
    export namespace JoinedRecordType {
        export class JoinConstituent extends pb_1.Message {
            constructor(data?: any[] | {
                name?: string;
                record_type?: string;
                outer_joined?: boolean;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("name" in data && data.name != undefined) {
                        this.name = data.name;
                    }
                    if ("record_type" in data && data.record_type != undefined) {
                        this.record_type = data.record_type;
                    }
                    if ("outer_joined" in data && data.outer_joined != undefined) {
                        this.outer_joined = data.outer_joined;
                    }
                }
            }
            get name() {
                return pb_1.Message.getField(this, 1) as string;
            }
            set name(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get record_type() {
                return pb_1.Message.getField(this, 2) as string;
            }
            set record_type(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get outer_joined() {
                return pb_1.Message.getField(this, 3) as boolean;
            }
            set outer_joined(value: boolean) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                name?: string;
                record_type?: string;
                outer_joined?: boolean;
            }) {
                const message = new JoinConstituent({});
                if (data.name != null) {
                    message.name = data.name;
                }
                if (data.record_type != null) {
                    message.record_type = data.record_type;
                }
                if (data.outer_joined != null) {
                    message.outer_joined = data.outer_joined;
                }
                return message;
            }
            toObject() {
                const data: {
                    name?: string;
                    record_type?: string;
                    outer_joined?: boolean;
                } = {};
                if (this.name != null) {
                    data.name = this.name;
                }
                if (this.record_type != null) {
                    data.record_type = this.record_type;
                }
                if (this.outer_joined != null) {
                    data.outer_joined = this.outer_joined;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (typeof this.name === "string" && this.name.length)
                    writer.writeString(1, this.name);
                if (typeof this.record_type === "string" && this.record_type.length)
                    writer.writeString(2, this.record_type);
                if (this.outer_joined !== undefined)
                    writer.writeBool(3, this.outer_joined);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): JoinConstituent {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new JoinConstituent();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.name = reader.readString();
                            break;
                        case 2:
                            message.record_type = reader.readString();
                            break;
                        case 3:
                            message.outer_joined = reader.readBool();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): JoinConstituent {
                return JoinConstituent.deserialize(bytes);
            }
        }
        export class Join extends pb_1.Message {
            constructor(data?: any[] | {
                left?: string;
                left_expression?: KeyExpression;
                right?: string;
                right_expression?: KeyExpression;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("left" in data && data.left != undefined) {
                        this.left = data.left;
                    }
                    if ("left_expression" in data && data.left_expression != undefined) {
                        this.left_expression = data.left_expression;
                    }
                    if ("right" in data && data.right != undefined) {
                        this.right = data.right;
                    }
                    if ("right_expression" in data && data.right_expression != undefined) {
                        this.right_expression = data.right_expression;
                    }
                }
            }
            get left() {
                return pb_1.Message.getField(this, 1) as string;
            }
            set left(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get left_expression() {
                return pb_1.Message.getWrapperField(this, KeyExpression, 2) as KeyExpression;
            }
            set left_expression(value: KeyExpression) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get right() {
                return pb_1.Message.getField(this, 3) as string;
            }
            set right(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            get right_expression() {
                return pb_1.Message.getWrapperField(this, KeyExpression, 4) as KeyExpression;
            }
            set right_expression(value: KeyExpression) {
                pb_1.Message.setWrapperField(this, 4, value);
            }
            static fromObject(data: {
                left?: string;
                left_expression?: ReturnType<typeof KeyExpression.prototype.toObject>;
                right?: string;
                right_expression?: ReturnType<typeof KeyExpression.prototype.toObject>;
            }) {
                const message = new Join({});
                if (data.left != null) {
                    message.left = data.left;
                }
                if (data.left_expression != null) {
                    message.left_expression = KeyExpression.fromObject(data.left_expression);
                }
                if (data.right != null) {
                    message.right = data.right;
                }
                if (data.right_expression != null) {
                    message.right_expression = KeyExpression.fromObject(data.right_expression);
                }
                return message;
            }
            toObject() {
                const data: {
                    left?: string;
                    left_expression?: ReturnType<typeof KeyExpression.prototype.toObject>;
                    right?: string;
                    right_expression?: ReturnType<typeof KeyExpression.prototype.toObject>;
                } = {};
                if (this.left != null) {
                    data.left = this.left;
                }
                if (this.left_expression != null) {
                    data.left_expression = this.left_expression.toObject();
                }
                if (this.right != null) {
                    data.right = this.right;
                }
                if (this.right_expression != null) {
                    data.right_expression = this.right_expression.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (typeof this.left === "string" && this.left.length)
                    writer.writeString(1, this.left);
                if (this.left_expression !== undefined)
                    writer.writeMessage(2, this.left_expression, () => this.left_expression.serialize(writer));
                if (typeof this.right === "string" && this.right.length)
                    writer.writeString(3, this.right);
                if (this.right_expression !== undefined)
                    writer.writeMessage(4, this.right_expression, () => this.right_expression.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Join {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Join();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.left = reader.readString();
                            break;
                        case 2:
                            reader.readMessage(message.left_expression, () => message.left_expression = KeyExpression.deserialize(reader));
                            break;
                        case 3:
                            message.right = reader.readString();
                            break;
                        case 4:
                            reader.readMessage(message.right_expression, () => message.right_expression = KeyExpression.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Join {
                return Join.deserialize(bytes);
            }
        }
    }
}
